<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="just a record of programmer's life"><title>scala notes | 墨写</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">scala notes</h1><a id="logo" href="/.">墨写</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">scala notes</h1><div class="post-meta">Aug 28, 2017<span> | </span><span class="category"><a href="/categories/program/">program</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#val-and-var"><span class="toc-number">1.</span> <span class="toc-text">val and var</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Classes-and-Objects"><span class="toc-number">2.</span> <span class="toc-text">Classes and Objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#singleton-objects"><span class="toc-number">3.</span> <span class="toc-text">singleton objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Operators"><span class="toc-number">4.</span> <span class="toc-text">Operators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#operatros-are-methods"><span class="toc-number">5.</span> <span class="toc-text">operatros are methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class"><span class="toc-number">6.</span> <span class="toc-text">Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inheritance"><span class="toc-number">7.</span> <span class="toc-text">Inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Build-in-control-structures"><span class="toc-number">8.</span> <span class="toc-text">Build-in control structures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-and-Closures"><span class="toc-number">9.</span> <span class="toc-text">Function and Closures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Control-Abstraction"><span class="toc-number">10.</span> <span class="toc-text">Control Abstraction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Curring"><span class="toc-number">11.</span> <span class="toc-text">Curring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#By-name-parameters"><span class="toc-number">12.</span> <span class="toc-text">By-name parameters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Traits"><span class="toc-number">13.</span> <span class="toc-text">Traits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Imports"><span class="toc-number">14.</span> <span class="toc-text">Imports</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Assertions-and-Unit-Testing"><span class="toc-number">15.</span> <span class="toc-text">Assertions and Unit Testing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Case-Classese-amp-amp-Pattern-Matching-amp-amp-Extractors"><span class="toc-number">16.</span> <span class="toc-text">Case Classese &amp;&amp; Pattern Matching &amp;&amp; Extractors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections"><span class="toc-number">17.</span> <span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-amp-Sets-and-Maps"><span class="toc-number">18.</span> <span class="toc-text">List &amp; Sets and Maps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collection-hierarchy"><span class="toc-number">19.</span> <span class="toc-text">collection hierarchy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-Parameterization"><span class="toc-number">20.</span> <span class="toc-text">Type Parameterization</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#variance-annotations"><span class="toc-number">21.</span> <span class="toc-text">variance annotations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Abstract-Members"><span class="toc-number">22.</span> <span class="toc-text">Abstract Members</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implicit-Conversions-and-Parameters"><span class="toc-number">23.</span> <span class="toc-text">Implicit Conversions and Parameters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Annotations"><span class="toc-number">24.</span> <span class="toc-text">Annotations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Modular-Programming-Using-Object"><span class="toc-number">25.</span> <span class="toc-text">Modular Programming Using Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Actors-and-Concurrency"><span class="toc-number">26.</span> <span class="toc-text">Actors and Concurrency</span></a></li></ol></div></div><div class="post-content"><h2 id="val-and-var"><a href="#val-and-var" class="headerlink" title="val and var"></a>val and var</h2><p>val: you could not reassign the variant, but whether the variant is mutable or not depends on its own type.<br>the parameters are vals( functional programming)</p>
<h2 id="Classes-and-Objects"><a href="#Classes-and-Objects" class="headerlink" title="Classes and Objects"></a>Classes and Objects</h2><h2 id="singleton-objects"><a href="#singleton-objects" class="headerlink" title="singleton objects"></a>singleton objects</h2><ol>
<li>a class and its companion object can access each other’s private members.</li>
<li>singleton objects inheriting from classes and traits in Chp 13</li>
<li>you should inherit from <code>Application</code> only when your program is relatively simple and single-threaded.</li>
</ol>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><h2 id="operatros-are-methods"><a href="#operatros-are-methods" class="headerlink" title="operatros are methods"></a>operatros are methods</h2><ol>
<li>infix: <code>a + b</code> : <code>(a).+(b)</code></li>
<li>prefix: <code>+</code>, <code>-</code>, <code>!</code> and <code>~</code>.(short hand of <code>unary_+</code>…)</li>
<li>postfix: methods that take no arguments</li>
<li>operator associativity: <code>:</code> right ro left.<br><em>no matter what associativity an operator has, its operands are always evaluated left to right</em></li>
</ol>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ol>
<li>the Scala compiler will place the code for the initializers of the fields into the primary constructor in the order in which they appear in the source code.</li>
<li>abstact classes<br>a class with abstract memeber must iself be declared abstract.</li>
<li>using <em>parameterless methods</em>(when no parameter), it supports the <em>uniform access principle</em>, which says that client code should not be affected by a decision to implement an attribute as a field or method.<br>encouraged: define methods that take no parameters and have no side effects as parameterless methods.</li>
</ol>
<h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><ol>
<li><em>subtyping</em> means that a value of the subclass can be used wherever a value of the superclass is required.</li>
<li><p>scala has two namespaces:</p>
<pre><code>1.  values(fields, methods, package, and singleton objects)
</code></pre><ol start="2">
<li><p>types(class and trait names)</p>
<p>so you could overriding a parameterless method with a field.</p>
</li>
</ol>
</li>
<li><p>factory object<br>a factory object contains methods that construct other objects. Clients would then use these factory methods for object construction rather than constructing the objects directly with <code>new</code></p>
</li>
<li><code>Null</code> is a subclass of every reference class. <code>Nothing</code> is a subtype of every other type.</li>
<li>value equality: <code>==</code>, reference equality: <code>eq</code>.</li>
<li><p>How to write an <em>equality method</em> ?</p>
<pre><code>1.  override `equals` in class `Any`: `override def equals(other: Any) = ...`
</code></pre><ol start="2">
<li>override <code>hashCode</code> method</li>
<li>when <code>equals</code> and <code>hashCode</code> are defined in terms of mutable fields, you may need more things to do.</li>
<li><p>to deal with the equality relationships between class and its subclass, you need to add one more method <code>def canEqual(other: Any): Boolean</code> for non-final class. For the example bellow, if the subclass <code>ColoredPoint</code> overrides <code>canEqual</code>, then the instance of <code>ColoredPoint</code> and <code>Point</code> is not equal, otherwise, it can be equal to a <code>Point</code> instance.</p>
<pre><code>//one example
</code></pre><p>class Point(val x: Int, val y: Int) {<br>override def hashCode = 41*(41 + x) + y<br>override def equals(other: Any) = other match {</p>
<pre><code>case that: Point =&amp;gt;                (that canEqual this) &amp;amp;&amp;amp;
    (this.x == that.x) &amp;amp;&amp;amp; (this.y == that.y)
case _ =&amp;gt; false
</code></pre><p>}<br>def canEqual(other: Any) = other.isInstanceOf[Point]<br>}<br>`</p>
</li>
</ol>
</li>
</ol>
<h2 id="Build-in-control-structures"><a href="#Build-in-control-structures" class="headerlink" title="Build-in control structures"></a>Build-in control structures</h2><ol>
<li>Try to challenge <code>while</code> loops in your code in the same way you challenges <code>var</code>s. <em>If there isn’t a good justification for a particular <code>while</code> or <code>do-while</code> loop, try to find a way to do the same thing without it.</em></li>
<li>For expression<br>using <code>for</code> expression may make things clearer<br><pre>`persons withFilter (p =&gt; !p.isMale) flatMap (p =&gt;<pre><code>(p.children map (c =&amp;gt; (p.name, c.name) ) )
</code></pre>//clear<br>for (p &lt;- persons; if !p.isMale; c &lt;- p.children)<pre><code>yield (p.name, c.name)
</code></pre><code>&lt;/pre&gt;
in fact, every</code>for<code>expression can be expressed in terms of the three higher-order functions</code>map<code>,</code>flatMap<code>and</code>withFilter<code>. So if you define</code>map<code>,</code>flatMap<code>,</code>withFilter<code>and</code>foreach<code>methods for your data type, your data types could support</code>for<code>expression. If you just define a subset of these methods, then your data type would support a subset of all possible</code>for` expressions.</pre></li>
<li><p>live without <code>break</code> and <code>continue</code>, <em>tail-call</em>.</p>
<pre><code>1.  If the solution is tail recursive, there won’t be any runtime overhead to be paid.（_tail-call optimization_)
</code></pre><ol start="2">
<li><em>tail-call optimization</em> is limited to situations in which a method or nested function calls itself directly as its last operation.</li>
</ol>
</li>
</ol>
<h2 id="Function-and-Closures"><a href="#Function-and-Closures" class="headerlink" title="Function and Closures"></a>Function and Closures</h2><ol>
<li>programs should be decomposed into many small functions that each do a well-defined task.</li>
<li>first-class functions<br> Every function value is an instance of some class that extends one of several <code>FuntionN</code> traits in packages <code>scala</code>. Each     <code>FunctionN</code> trait has an <code>apply</code> method used to invoke the function.</li>
<li>partially applied functions<br><pre><code>someNumbers.forach(sum _)</code></pre><br> you could leave off the <code>-</code> here (only when a function type is expected).</li>
<li>closures<br>when a closure accesses some variable that has several different copies as the program runs, the instance used is the one that was active at the time the closure was created.</li>
</ol>
<h2 id="Control-Abstraction"><a href="#Control-Abstraction" class="headerlink" title="Control Abstraction"></a>Control Abstraction</h2><h2 id="Curring"><a href="#Curring" class="headerlink" title="Curring"></a>Curring</h2><h2 id="By-name-parameters"><a href="#By-name-parameters" class="headerlink" title="By-name parameters"></a>By-name parameters</h2><pre><code>&lt;pre&gt;`def byNameAssert(predicate: =&amp;gt; Boolean) = 
    if (assertionsEnabled &amp;amp;&amp;amp; !predicate)
        throw new AssertionError

def boolAssert(predicate: Boolean) = 
    if(assertionEnabled &amp;amp;&amp;amp; !predicate)
        throw new AsserstionError

//evaluate (5&amp;gt;3) before the call to boolAssert
boolAssert(5 &amp;gt; 3)
//the expression (5&amp;gt;3) is not evaluated before the call to byNameAssert.
byNameAssert(5 &amp;gt; 3)
`&lt;/pre&gt;
</code></pre><h2 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h2><ol>
<li><p>A trait differs with a class:</p>
<pre><code>1.  no parameters
</code></pre><ol start="2">
<li><code>super</code> calls are dynamically bound</li>
</ol>
</li>
<li>if a trait delcares a superclass, then it can only be mixed into a class that also extends that superclass.<br><pre>`trait Doubling extends IntQueue {<pre><code>abstract override def put(x: Int) { super.put(2*x) }
</code></pre>}<br><code>&lt;/pre&gt;</code>super<code>call is dynamically bound, it will work so long as the trait is mixed in _after_ another trait or class that gives a concrete definition to the method.</code>abstract override` (only used for traits) means that the trait must be mixed into some class that has a concrete definition ot the method.</pre></li>
<li>traits as stackable modifications    <pre><code>val queue = (new BasicIntQueue                    with Filtering with Incrementing)</code></pre><br> traits further to the right take effect first. when determine the     <code>super</code> call, use <em>linearization</em>!4.  If it might be reused in multiple, unrelated classes, use trait;<br>if you want to inherit from it in Java code, use abstract class;<br>if you plan to distribute it in compiled form, lean towards an abstract class;<br>if efficiency is very important, lean towards using a class.</li>
</ol>
<h2 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h2><ol>
<li><p>flexible:</p>
<pre><code>*   may appear anywhere
</code></pre><ul>
<li>may refer to objects(singleton or regular) in addition to packages</li>
<li>let you rename and hide some of the imported members<pre>`import Fruits.{Apple =&gt; McIntosh}   //rename apple
//import all Fruits except for Apple
import Fruits.{Apple =&gt; _, _}
`</pre></li>
</ul>
</li>
<li>scope of protection<br><code>private[X]</code> or <code>protected[X]</code> means that access is private or protected “up to” X, where X disignates some enclosing package, class or singleton object.</li>
<li>package objects<br>Each package is allowed to have one package object.</li>
</ol>
<h2 id="Assertions-and-Unit-Testing"><a href="#Assertions-and-Unit-Testing" class="headerlink" title="Assertions and Unit Testing"></a>Assertions and Unit Testing</h2><pre><code>to be read
</code></pre><h2 id="Case-Classese-amp-amp-Pattern-Matching-amp-amp-Extractors"><a href="#Case-Classese-amp-amp-Pattern-Matching-amp-amp-Extractors" class="headerlink" title="Case Classese &amp;&amp; Pattern Matching &amp;&amp; Extractors"></a>Case Classese &amp;&amp; Pattern Matching &amp;&amp; Extractors</h2><ol>
<li><p>case classes</p>
<pre><code>1.  _case class_ addes a factory method with the name of class.2.  all arguments in the parameter list of a case class implicitly get a     `val` prefix, so they are maintained as fields.
</code></pre><ol start="3">
<li>the compiler addes methods <code>toString</code>, <code>hashCode</code>, <code>equals</code> to case     class.</li>
<li>the compiler adds a <code>copy</code> method for making modified copies.</li>
</ol>
</li>
<li>a variable pattern matches any object, Scala binds the variable to whatever the object is.<br>To treat a lowercase identifier as a constant in a pattern match, use back-tick <code></code>pi<code></code>.</li>
<li>typed patterns<pre>`def generalSize(x: Any) = x match {
    case s: String =&gt; s.length
    case m: Map[_, _] =&gt; m.size
    case _ =&gt; -1
}
`</pre>
because of _type erasure_, you could not chek `case m: Map[Int, Int]`. Only exception to the erasure rule is arrays. `case a: Array[String]` . The element type of an array is stored with the array value, so you can pattern match on it.
variable binding:
<pre>`expr match {
    case Unop(&quot;abs&quot;, e @ Unop(&quot;abs&quot;, _) ) =&gt; e
    case _ =&gt;    }
`</pre></li>
<li>A <em>sealed class</em> cannot have any new subclasses added except the ones in the same file. If we want Scala compiler help to detect missing patterns, we should make the superclass of case classes sealed.</li>
<li><p>case sequences as partial functions6.  patterns in <code>for</code> expressions<br> <code>for (Some(fruit) &amp;lt;- results) println(fruit)</code><br>Extractors</p>
<hr>
</li>
<li><p>A extractor is an object that has a method called <code>unapply</code> or <code>unapplySeq</code>.</p>
<pre>`object Domain {
    def apply(parts: String*): String =            parts.reverse.mkString(&quot;.&quot;)
    def unapplySeq(whole: String): Option[Seq[String]] =            Some(whole.split(&quot;\\.&quot;).reverse)
}
dom match {
    case Domain(&quot;org&quot;, &quot;acm&quot;) =&gt; println(&quot;acm.org&quot;)
    case Domain(&quot;net&quot;, _*) =&gt; println(&quot;a .net domain&quot;)
`</pre></li>
<li>Compared with case classes, extractors is <em>representation independence</em>, that’s to say, patterns have nothing to do with the data type of the object that’s selected on. While case classes also have their advantages: short code and more efficient.</li>
</ol>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><h2 id="List-amp-Sets-and-Maps"><a href="#List-amp-Sets-and-Maps" class="headerlink" title="List &amp; Sets and Maps"></a>List &amp; Sets and Maps</h2><ol>
<li>type inference algorithm:<br>Type inference is flow based. In a method application <code>m(args)</code>, it first checks whether the method <code>m</code> has a known type. If it has, that type is used to infer the expected type of the arguments.<br><pre><code>msort((x: Char, y: Char) =&amp;gt; x &amp;gt; y)(abcdb)
abcde sortWith (_ &amp;gt; _)</code></pre><br>the type of <code>abcde</code> is <code>List[Char]</code>, so we do not need to write it explicitly, could just use <code>_</code>.</li>
<li>When designing a polymorphic method that takes some non-function arguments and a funtion argument, place the function argument last in a curried parameter list.( The methods’ correct instance type can be inferred from the non-function arguments).</li>
<li><code>scala.collection.mutable.Set()</code> and <code>scala.collection.mutable.Map()</code> usually uses hash talbe. While for <code>scala.collection.immutable.{Set(), Map()}</code>, it depends how many elements you pass to it. If there are more than 5 elements, then they use hash methods.</li>
</ol>
<h2 id="collection-hierarchy"><a href="#collection-hierarchy" class="headerlink" title="collection hierarchy"></a>collection hierarchy</h2><ol>
<li>the difference between <code>Traversable</code> and <code>Iterable</code> ?<br>see discussion in <a href="http://stackoverflow.com/questions/7425370/scala-what-is-the-difference-between-traversable-and-iterable-traits-in-scala-c" target="_blank" rel="noopener">stackOverflow</a></li>
<li>All collections except streams and views are strict. The only way to go from a strict to a lazy collection is via the <code>view</code> method. The only way to go back is via <code>force</code>.</li>
<li><p>a <em>view</em> is a special kind of collection that represents some base collection, but implements all of its transformers lazily.</p>
<pre><code>1.  Using view could avoiding intermediate results.
</code></pre><ol start="2">
<li>create a subwindow for mutable sequences to update selectively some elements of that sequence.<pre>`findRalindrome(words.view take 10000) //1
//2
val arr = (0 to 9).toArray
val subarr = arr.view.slice(3, 6)
do_something(subarr) // update partial of arr
`</pre></li>
</ol>
</li>
<li>Factoring out common operations<br><code>CanBuildFrom</code>: check this <a href="http://blog.bruchez.name/2012/08/getting-to-know-canbuildfrom-without-phd.html" target="_blank" rel="noopener">post</a></li>
<li>integrate a new collection class into the framework<pre><code>1.  decide whether the collection should be mutable or immutable
</code></pre><ol start="2">
<li>pick the right base traits for the collection</li>
<li>inherit from the right implementation trait to implement most collection operations</li>
<li>if you want <code>map</code> and similar operations to return instances of your collection type, provide an implicit <code>CanBuildFrom</code> in your class’s companion object.</li>
</ol>
</li>
</ol>
<h2 id="Type-Parameterization"><a href="#Type-Parameterization" class="headerlink" title="Type Parameterization"></a>Type Parameterization</h2><h2 id="variance-annotations"><a href="#variance-annotations" class="headerlink" title="variance annotations"></a>variance annotations</h2><ol>
<li><em>covariant</em>(<code>+</code>), <em>contravariant</em>(<code>-</code>), <em>nonvariant</em></li>
<li>In a purely functional word, many types are natureally covariant. However, the situation changes once you introduce mutable data. In fact, if a generic parameter type appears as the type of a method parameter, the containing class or trait may not be covariant in that type parameter.</li>
<li>In scala, arrays are <em>nonvariant</em>.  you could cast an array of <code>T</code>s to an array of any supertype of <code>T</code><pre>`val a1 = Array(&quot;abc&quot;)
val a2: Array[Object] =        a1.asInstanceOf[Array[Object]]
`</pre></li>
<li><em>lower bound</em><br><pre>`class Queue[T](private val leading: List[T],<pre><code>private val trailing: List[T] ) {
def enqueue[U &amp;gt;: T](x: U) =            new Queue[U](leading, x :: trailing)//...
</code></pre>}<br><code>&lt;/pre&gt;
 You coud append an</code>Orange<code>to a</code>Queue[Apple]<code>. The result will be a</code>Queue[Fruit]`.s</pre></li>
<li><em>Liskov Substitution Principle</em>: It is safe to assume that a type <code>T</code> is a subtype of a type <code>U</code> if you can substitute a value of type <code>T</code> whereer a value of type <code>U</code> is required.  The principle holds if <code>T</code> supports the same operations as <code>U</code> and ll of <code>T</code>‘s operations require less and provides more than the corresponding operations in <code>U</code>.<br>When you write the function type <code>A =&amp;gt; B</code>, Scala expands this to <code>Function1[A,B]</code>.<br><pre>`trait Function[-S, +T] {<pre><code>def apply(x: S): T
</code></pre>}<br><code>&lt;/pre&gt;
The</code>Function1<code>in the trait is contravariant in the function argument type</code>S<code>and covariant in the result type</code>T`, because argument are somthing that’s required, whereas results are something that’s provided.</pre></li>
<li><em>upper bound</em>    <pre><code>def orderedMergeSort[T &amp;lt;: Ordered[T]](xs: List[T]): List[T] = {
...
}</code></pre><br> Means the element type of the list passed to <code>orderedMergeSort</code> must be a subtype of <code>Ordered</code>.</li>
<li>object private data<br><pre>`class Queue[+T] private(<pre><code>private[this] var leading: List[T],
private[this] var trailing: List[T]
</code></pre>){ … }<br><code>&lt;/pre&gt;
 Here type</code>T<code>is a covariant type, but</code>leading<code>and</code>trailing<code>are  variable, there should be a contravariant position, there will be a compiler error. But if we mark</code>private[this]`, the compiler has special handling in it’s variance checking for this case.</pre></li>
</ol>
<h2 id="Abstract-Members"><a href="#Abstract-Members" class="headerlink" title="Abstract Members"></a>Abstract Members</h2><ol>
<li>one example<pre>`trait Abstract {
    type T  //abstract type
    def transform(x: T): T
    val initial: T
    var current: T
}
`</pre></li>
<li>For abstract vals, it could only be implemented by a <code>val</code> definition; For abstract method, it may be implemented by both concrete method definitions and concrete <code>val</code> definitions.</li>
<li><p>initializing abstract vals    <pre>`trait RationalTrait {</pre></p>
<pre><code>val numerArg: Int
val denomArg: Int
</code></pre><p>}<br>//anonymous class<br>new RationalTrait {</p>
<pre><code>val numerArg = 1
val denomArg = 2
require(denomArg != 0)//exception
...
</code></pre><p>}<br>//pre-initialized<br>new {</p>
<pre><code>val numerArg = 1 * x
val denomArg = 2 * x
</code></pre><p>} with RationalTrait<br><code>&lt;/pre&gt;
Here we first define a trait</code>RationalTrait<code>with abstract vals, then we have an _anonymous class_ that mixes in the trait. The anonymous class is initialized _after_ the</code>RationalTrait<code>, so the values of</code>numerArg<code>and</code>denomArg<code>are not available during the initialization of</code>RationalTrait<code>(i.e. theses two are 0). so the</code>require<code>invocation will fail.
so, a class parameter argument is evaluated _before_ it is passed to the class constructor(unless by-name). An implementing</code>val` definition in a subclass, by contrast, is evaluated only <em>after</em> the superclass has been initialized. Two solutions:</p>
<pre><code>*   pre-initialized
</code></pre><ul>
<li>lazy vals</li>
</ul>
</li>
<li>path-dependent types<br><pre>`class DogFood extends Food<br>class Dog extends Animal {<pre><code>type SuitableFood =  DogFood
override def eat(food: DogFood) {}
</code></pre>}<br>val bessy = new Dog<br>val lassie = new Dog<br><code>&lt;/pre&gt;</code>bessy.SuitableFood<code>is a _path-dependent type_ and it’s the same type as</code>lassie.SuitableFood<code>. while
&lt;pre&gt;</code>class Outer {<pre><code>class Inner
</code></pre>}<br>val o1 = new Outer<br>val o2 = new Outer<br><code>&lt;/pre&gt;</code>o1.Inner<code>is a different type as</code>o2.Inner<code>. They are subtypes of</code>OuterInner`.</pre></li>
<li>structural subtyping<br>you get a subtyping relationship simply because two types have the same members.<pre><code>*   If you want to define a _Pasture_ class that contains animals that eat grass, you could write the type `Animal { type SuitableFood = Grass }`. so you could define _Pasture_ like this:
</code></pre>  class Pasture {<br><pre><code>val animals: List[ Animal {type SuitableFood = Grass} ] = Nil
}</code></pre><ul>
<li>If you want to group together a number of classes that were written by someone else.    <pre><code>def using[T &amp;lt;: { def close(): Unit }, S](obj: T)
(operation: T =&amp;gt; S) = {
val result = operation(obj)
obj.close()
result
}</code></pre><br>No base type is specified, so Scala would use <code>AnyRef</code> automatically, and the type <code>T</code> must support <code>close()</code> method.</li>
</ul>
</li>
</ol>
<h2 id="Implicit-Conversions-and-Parameters"><a href="#Implicit-Conversions-and-Parameters" class="headerlink" title="Implicit Conversions and Parameters"></a>Implicit Conversions and Parameters</h2><ol>
<li><p>rules for implicits:</p>
<pre><code>1.  Marking Rule: Only definitions marked `implicit` are available.
</code></pre><ol start="2">
<li>Scope Rule: An inserted implicit conversion must be in scope as a single identifier, or be associated with the source or target type of the conversion(i.e. companion object).</li>
<li>One-at-a-time Rule: Only one implicit is tried.</li>
<li>Explicits-First Rule: Whenever code type checks as it is written, no implicits are attempted.</li>
</ol>
</li>
<li><p>Where implicits are tried:</p>
<pre><code>1.  implicit conversion to an expected type
</code></pre><p><pre>`//1<br>implicit def int2double(x: Int): Double = x.toDouble<br>var i: Double = 1<br>//2 receiver<br>implicit def intToRational(x: Int) =        new Rational(x, 1)<br>1 + oneHalf   //intToRational(1) + oneHalf<br>//3    def maxList<a href="elements: List[t]" target="_blank" rel="noopener">T</a></pre></p>
<pre><code>(implicit orderer: T =&amp;gt; Ordered[T]): T =        elements match{
    case List() =&amp;gt;
        throw new IllegalArgumentException(&amp;quot;empty list!&amp;quot;)
    case List(x) =&amp;gt; x
    case x :: rest =&amp;gt;
        val maxRest = maxList(rest) //(orderer) is implicit
        if (x &amp;gt; maxRest) x //orderer(x) is implicit
        else maxRest
}
</code></pre><p>maxList(List(1,5,10,3))  //res: Int = 10<br>//view bound<br>def maxList2<a href="elements: List[T]" target="_blank" rel="noopener">T &lt;% Ordered[T] </a>: T =            { …. }<br>//upper bound<br>def maxList3[T &lt;: Ordered[T] }(elements: List[T]): T =        { … }</p>
<pre><code>2.  Converting the receiver: interoperating with new types; simulating new syntax

3.  implicit parameters
</code></pre><p>view bound: We could use <em>view bound</em> to shorten the method header.<br>The difference between view bound and upper bounds <code>T &amp;lt;: Ordered[T]</code> is that upper bounds require that <code>T</code> is a subtype of <code>Ordered[T]</code>, however, for view bound, it only requires that T can <em>be treated as an <code>Ordered[T]</code></em>. So we could pass a <code>List[Int]</code> to <code>maxList</code> and <code>maxList2</code> but no to <code>maxList3</code>.</p>
</li>
<li><p>multiple conversions<br>choose a more <em>sprcific</em> one. One implicit conversion is more spercific than another if one of the following applies:</p>
<pre><code>1.  The argument type of the former is a subtype of the latters’s
</code></pre><ol start="2">
<li>Both conversions are methods, and the enclosing class of the former extends the enclosing class of the latter.</li>
</ol>
</li>
</ol>
<h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><ol>
<li>standard annotations:<br><code>@deprecated</code> <code>@volatitle</code> <code>@serializable</code> <code>@SerialVersionUID</code> <code>@transient</code><br><a href="mailto:`@scala.reflect.BeanProperty" target="_blank" rel="noopener">`@scala.reflect.BeanProperty</a><code></code>@tailrec<code></code>@unchecked<code></code>@native`</li>
</ol>
<h2 id="Modular-Programming-Using-Object"><a href="#Modular-Programming-Using-Object" class="headerlink" title="Modular Programming Using Object"></a>Modular Programming Using Object</h2><ol>
<li><em>self type</em><br>check <a href="http://stackoverflow.com/questions/1990948/what-is-the-difference-between-self-types-and-trait-subclasses" target="_blank" rel="noopener">this</a> post in StackOverflow.</li>
<li><em>singleton type</em><br>A singleton type is extremely specific and holds only one object. check this <a href="http://hongjiang.info/scala-type-system-singleton-type/" target="_blank" rel="noopener">post</a></li>
</ol>
<h2 id="Actors-and-Concurrency"><a href="#Actors-and-Concurrency" class="headerlink" title="Actors and Concurrency"></a>Actors and Concurrency</h2><p>not too much to record, the example showed in <em>Programming in Scala</em> is worth understanding.</p>
</div><div class="tags"><a href="/tags/programming/">programming</a><a href="/tags/scala/">scala</a></div><div class="post-nav"><a class="pre" href="/2017/09/10/ESL-chap2-notes/">ESL_chap2_notes</a><a class="next" href="/2016/11/22/读Paper-information-extraction-by-acquiring-external-evidence-with-reinforcement-learning/">[读Paper]information-extraction-by-acquiring-external-evidence-with-reinforcement-learning</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/life/">life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/math/">math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/program/">program</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/plot/" style="font-size: 15px;">plot</a> <a href="/tags/ESL/" style="font-size: 15px;">ESL</a> <a href="/tags/programming/" style="font-size: 15px;">programming</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/ML/" style="font-size: 15px;">ML</a> <a href="/tags/摄影/" style="font-size: 15px;">摄影</a> <a href="/tags/scala/" style="font-size: 15px;">scala</a> <a href="/tags/NLP/" style="font-size: 15px;">NLP</a> <a href="/tags/Reinforcement-learning/" style="font-size: 15px;">Reinforcement learning</a> <a href="/tags/IR/" style="font-size: 15px;">IR</a> <a href="/tags/Reading/" style="font-size: 15px;">Reading</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/photograph-canon/">photograph-canon</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/22/linux-tips/">linux_tips</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/ESL-chap2-notes/">ESL_chap2_notes</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/28/scala-notes/">scala notes</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/读Paper-information-extraction-by-acquiring-external-evidence-with-reinforcement-learning/">[读Paper]information-extraction-by-acquiring-external-evidence-with-reinforcement-learning</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/10/Libnids抓不到包/">Libnids抓不到包</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/25/effective-c-notes/">effective c++ notes</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/24/《百年孤独》家谱/">《百年孤独》家谱</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/25/matplotlib/">matplotlib</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">墨写.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>